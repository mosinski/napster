<% if @user.ptaki == '1' %>
<div id="container"></div>
<% elsif @user.kolka == '1' %>
<canvas height="619" width="1366"></canvas>
<% elsif @user.samochod == '1' %>
<canvas height="619" width="1366"></canvas>
<% elsif @user.szesciany == '1' %>
<canvas height="619" width="1366"></canvas>
<% elsif @user.woda == '1' %>
<canvas height="619" width="1366"></canvas>
<% end %>
<p class="tymczasowe">
<% if (@user.avatarurl.nil?) or (@user.avatarurl == '') %>
  <%= image_tag avatar_url(@user),:width => 150, :height => 150, :class => "avatar", :id => "avatar_duzy" %><br><br>
  <% else %>
  <%= image_tag(@user.avatarurl, :class => "avatar", :size => "150x150", :id => "avatar_duzy") %><br><br>
  <% end %>
<%= image_tag("avatar_border.png", :class => "ramka") %>
</p>

<div class="nick_konta">
  <%= @user.username %>
</div>

<div class="email_konta">
  <%= @user.email %>
</div>

<div class="zaprosiles">
<% if current_user.username == @user.username %>
<font id="szary">Zaprosiłes</font>
<ul>
  <% for friendship in @user.friendships %>
   <li id="niebieski">
     <% if current_user.username == @user.username or current_user.username == friendship.friend.username %>
      <%=h friendship.friend.username %>
	(<%= link_to "x", friendship, confirm: 'Jesteś pewnien że chcesz zerwać znajomość?' %>)
      <% end %>
    </li>
   <% end %>
</ul>
<% else %>
<% end %>
</div>

<div class="odpowiedziano">
<font id="szary">Znajomi</font>
<ul style="list-style-type: decimal;">
  <% for user in @user.inverse_friends %>
    <li id="niebieski">
<% if (user.avatarurl.nil?) or (user.avatarurl == '') %>
<%= image_tag avatar_url(user), :width => 60, :height => 60, :title => user.username, :id => "avatar_maly" %>
<% else %>
<%= image_tag(user.avatarurl, :class => "avatar", :size => "60x60", :title => user.username, :id => "avatar_maly") %>
<% end %>
<%= link_to 'x', friendship, confirm: 'Jesteś pewnien że chcesz zerwać znajomość?' %>
<div class="avatar_przekierowanie">
<%= link_to image_tag("nothing.png",:title => user.username), user %>
</div>
<% if current_user.username == user.username %>
<% end %>
</li>
  <% end %>
</ul>
</div>
<div class="przyciski">
<%= link_to 'Edytuj', edit_user_path(@user), :class => 'btn btn-success'%> <%= link_to 'Powrót', fortunes_path, :class => 'btn btn-warning' %>
</div>
<% if @user.ptaki == '1' %>
		<script>

			// Based on http://www.openprocessing.org/visuals/?visualID=6910

			var Boid = function() {

				var vector = new THREE.Vector3(),
				_acceleration, _width = 500, _height = 500, _depth = 200, _goal, _neighborhoodRadius = 100,
				_maxSpeed = 4, _maxSteerForce = 0.1, _avoidWalls = false;

				this.position = new THREE.Vector3();
				this.velocity = new THREE.Vector3();
				_acceleration = new THREE.Vector3();

				this.setGoal = function ( target ) {

					_goal = target;

				}

				this.setAvoidWalls = function ( value ) {

					_avoidWalls = value;

				}

				this.setWorldSize = function ( width, height, depth ) {

					_width = width;
					_height = height;vector
					_depth = depth;

				}

				this.run = function ( boids ) {

					if ( _avoidWalls ) {

						vector.set( - _width, this.position.y, this.position.z );
						vector = this.avoid( vector );
						vector.multiplyScalar( 5 );
						_acceleration.addSelf( vector );

						vector.set( _width, this.position.y, this.position.z );
						vector = this.avoid( vector );
						vector.multiplyScalar( 5 );
						_acceleration.addSelf( vector );

						vector.set( this.position.x, - _height, this.position.z );
						vector = this.avoid( vector );
						vector.multiplyScalar( 5 );
						_acceleration.addSelf( vector );

						vector.set( this.position.x, _height, this.position.z );
						vector = this.avoid( vector );
						vector.multiplyScalar( 5 );
						_acceleration.addSelf( vector );

						vector.set( this.position.x, this.position.y, - _depth );
						vector = this.avoid( vector );
						vector.multiplyScalar( 5 );
						_acceleration.addSelf( vector );

						vector.set( this.position.x, this.position.y, _depth );
						vector = this.avoid( vector );
						vector.multiplyScalar( 5 );
						_acceleration.addSelf( vector );

					}/* else {

						this.checkBounds();

					}
					*/

					if ( Math.random() > 0.5 ) {

						this.flock( boids );

					}

					this.move();

				}

				this.flock = function ( boids ) {

					if ( _goal ) {

						_acceleration.addSelf( this.reach( _goal, 0.005 ) );

					}

					_acceleration.addSelf( this.alignment( boids ) );
					_acceleration.addSelf( this.cohesion( boids ) );
					_acceleration.addSelf( this.separation( boids ) );

				}

				this.move = function () {

					this.velocity.addSelf( _acceleration );

					var l = this.velocity.length();

					if ( l > _maxSpeed ) {

						this.velocity.divideScalar( l / _maxSpeed );

					}

					this.position.addSelf( this.velocity );
					_acceleration.set( 0, 0, 0 );

				}

				this.checkBounds = function () {

					if ( this.position.x >   _width ) this.position.x = - _width;
					if ( this.position.x < - _width ) this.position.x =   _width;
					if ( this.position.y >   _height ) this.position.y = - _height;
					if ( this.position.y < - _height ) this.position.y =  _height;
					if ( this.position.z >  _depth ) this.position.z = - _depth;
					if ( this.position.z < - _depth ) this.position.z =  _depth;

				}

				//

				this.avoid = function ( target ) {

					var steer = new THREE.Vector3();

					steer.copy( this.position );
					steer.subSelf( target );

					steer.multiplyScalar( 1 / this.position.distanceToSquared( target ) );

					return steer;

				}

				this.repulse = function ( target ) {

					var distance = this.position.distanceTo( target );

					if ( distance < 150 ) {

						var steer = new THREE.Vector3();

						steer.sub( this.position, target );
						steer.multiplyScalar( 0.5 / distance );

						_acceleration.addSelf( steer );

					}

				}

				this.reach = function ( target, amount ) {

					var steer = new THREE.Vector3();

					steer.sub( target, this.position );
					steer.multiplyScalar( amount );

					return steer;

				}

				this.alignment = function ( boids ) {

					var boid, velSum = new THREE.Vector3(),
					count = 0;

					for ( var i = 0, il = boids.length; i < il; i++ ) {

						if ( Math.random() > 0.6 ) continue;

						boid = boids[ i ];

						distance = boid.position.distanceTo( this.position );

						if ( distance > 0 && distance <= _neighborhoodRadius ) {

							velSum.addSelf( boid.velocity );
							count++;

						}

					}

					if ( count > 0 ) {

						velSum.divideScalar( count );

						var l = velSum.length();

						if ( l > _maxSteerForce ) {

							velSum.divideScalar( l / _maxSteerForce );

						}

					}

					return velSum;

				}

				this.cohesion = function ( boids ) {

					var boid, distance,
					posSum = new THREE.Vector3(),
					steer = new THREE.Vector3(),
					count = 0;

					for ( var i = 0, il = boids.length; i < il; i ++ ) {

						if ( Math.random() > 0.6 ) continue;

						boid = boids[ i ];
						distance = boid.position.distanceTo( this.position );

						if ( distance > 0 && distance <= _neighborhoodRadius ) {

							posSum.addSelf( boid.position );
							count++;

						}

					}

					if ( count > 0 ) {

						posSum.divideScalar( count );

					}

					steer.sub( posSum, this.position );

					var l = steer.length();

					if ( l > _maxSteerForce ) {

						steer.divideScalar( l / _maxSteerForce );

					}

					return steer;

				}

				this.separation = function ( boids ) {

					var boid, distance,
					posSum = new THREE.Vector3(),
					repulse = new THREE.Vector3();

					for ( var i = 0, il = boids.length; i < il; i ++ ) {

						if ( Math.random() > 0.6 ) continue;

						boid = boids[ i ];
						distance = boid.position.distanceTo( this.position );

						if ( distance > 0 && distance <= _neighborhoodRadius ) {

							repulse.sub( this.position, boid.position );
							repulse.normalize();
							repulse.divideScalar( distance );
							posSum.addSelf( repulse );

						}

					}

					return posSum;

				}

			}

		</script>

		<script>

			var SCREEN_WIDTH = window.innerWidth,
			SCREEN_HEIGHT = window.innerHeight,
			SCREEN_WIDTH_HALF = SCREEN_WIDTH  / 2,
			SCREEN_HEIGHT_HALF = SCREEN_HEIGHT / 2;

			var camera, scene, renderer,
			birds, bird;

			var boid, boids;

			var stats;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
				camera.position.z = 450;

				scene = new THREE.Scene();

				birds = [];
				boids = [];

				for ( var i = 0; i < 200; i ++ ) {

					boid = boids[ i ] = new Boid();
					boid.position.x = Math.random() * 400 - 200;
					boid.position.y = Math.random() * 400 - 200;
					boid.position.z = Math.random() * 400 - 200;
					boid.velocity.x = Math.random() * 2 - 1;
					boid.velocity.y = Math.random() * 2 - 1;
					boid.velocity.z = Math.random() * 2 - 1;
					boid.setAvoidWalls( true );
					boid.setWorldSize( 500, 500, 400 );

					bird = birds[ i ] = new THREE.Mesh( new Bird(), new THREE.MeshBasicMaterial( { color:Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					bird.phase = Math.floor( Math.random() * 62.83 );
					bird.position = boids[ i ].position;
					scene.add( bird );


				}

				renderer = new THREE.CanvasRenderer();
				// renderer.autoClear = false;
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.left = '0px';
				stats.domElement.style.top = '0px';

				document.getElementById( 'container' ).appendChild(stats.domElement);

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				var vector = new THREE.Vector3( event.clientX - SCREEN_WIDTH_HALF, - event.clientY + SCREEN_HEIGHT_HALF, 0 );

				for ( var i = 0, il = boids.length; i < il; i++ ) {

					boid = boids[ i ];

					vector.z = boid.position.z;

					boid.repulse( vector );

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				for ( var i = 0, il = birds.length; i < il; i++ ) {

					boid = boids[ i ];
					boid.run( boids );

					bird = birds[ i ];

					color = bird.material.color;
					color.r = color.g = color.b = ( 500 - bird.position.z ) / 1000;

					bird.rotation.y = Math.atan2( - boid.velocity.z, boid.velocity.x );
					bird.rotation.z = Math.asin( boid.velocity.y / boid.velocity.length() );

					bird.phase = ( bird.phase + ( Math.max( 0, bird.rotation.z ) + 0.1 )  ) % 62.83;
					bird.geometry.vertices[ 5 ].y = bird.geometry.vertices[ 4 ].y = Math.sin( bird.phase ) * 5;

				}

				renderer.render( scene, camera );

			}

		</script>
<!-- koniec skryptu ptaki-->
<% elsif @user.kolka == '1' %>
		<script>

			var container, stats;
			var camera, scene, renderer, group, particle;
			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();

				var PI2 = Math.PI * 2;
				var program = function ( context ) {

					context.beginPath();
					context.arc( 0, 0, 1, 0, PI2, true );
					context.closePath();
					context.fill();

				}

				group = new THREE.Object3D();
				scene.add( group );

				for ( var i = 0; i < 1000; i++ ) {

					particle = new THREE.Particle( new THREE.ParticleCanvasMaterial( { color: Math.random() * 0x808008 + 0x808080, program: program } ) );
					particle.position.x = Math.random() * 2000 - 1000;
					particle.position.y = Math.random() * 2000 - 1000;
					particle.position.z = Math.random() * 2000 - 1000;
					particle.scale.x = particle.scale.y = Math.random() * 10 + 5;
					group.add( particle );
				}

				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				camera.lookAt( scene.position );

				group.rotation.x += 0.01;
				group.rotation.y += 0.02;

				renderer.render( scene, camera );

			}

		</script>
<% elsif @user.samochod == '1' %>
		<script>

			var container, stats;
			var camera, scene, projector, renderer;

			var PI2 = Math.PI * 2;

			var programFill = function ( context ) {

				context.beginPath();
				context.arc( 0, 0, 1, 0, PI2, true );
				context.closePath();
				context.fill();

			}

			var programStroke = function ( context ) {

				context.lineWidth = 0.05;
				context.beginPath();
				context.arc( 0, 0, 1, 0, PI2, true );
				context.closePath();
				context.stroke();

			}

			var mouse = { x: 0, y: 0 }, INTERSECTED;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> canvas - interactive particles';
				container.appendChild( info );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 300, 500 );

				scene = new THREE.Scene();

				for ( var i = 0; i < 100; i ++ ) {

					var particle = new THREE.Particle( new THREE.ParticleCanvasMaterial( { color: Math.random() * 0x808080 + 0x808080, program: programStroke } ) );
					particle.position.x = Math.random() * 800 - 400;
					particle.position.y = Math.random() * 800 - 400;
					particle.position.z = Math.random() * 800 - 400;
					particle.scale.x = particle.scale.y = Math.random() * 10 + 10;
					scene.add( particle );

				}

				projector = new THREE.Projector();

				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			var radius = 600;
			var theta = 0;

			function render() {

				// rotate camera

				theta += 0.2;

				camera.position.x = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.y = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.z = radius * Math.cos( theta * Math.PI / 360 );
				camera.lookAt( scene.position );

				// find intersections

				camera.updateMatrixWorld();

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.program = programStroke;

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.material.program = programFill;

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.program = programStroke;

					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}

		</script>
<% elsif @user.szesciany == '1' %>
		<script>

			var container, stats;

			var camera, scene, renderer;

			var geometry, group;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 500;

				scene = new THREE.Scene();

				var geometry = new THREE.CubeGeometry( 100, 100, 100 );
				var material = new THREE.MeshNormalMaterial();

				group = new THREE.Object3D();

				for ( var i = 0; i < 200; i ++ ) {

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 2000 - 1000;
					mesh.position.y = Math.random() * 2000 - 1000;
					mesh.position.z = Math.random() * 2000 - 1000;
					mesh.rotation.x = Math.random() * 360 * ( Math.PI / 180 );
					mesh.rotation.y = Math.random() * 360 * ( Math.PI / 180 );
					mesh.matrixAutoUpdate = false;
					mesh.updateMatrix();
					group.add( mesh );

				}

				scene.add( group );

				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove(event) {

				mouseX = ( event.clientX - windowHalfX ) * 10;
				mouseY = ( event.clientY - windowHalfY ) * 10;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				group.rotation.x = Math.sin( Date.now() * 0.0007 ) * 0.5;
				group.rotation.y = Math.sin( Date.now() * 0.0003 ) * 0.5;
				group.rotation.z = Math.sin( Date.now() * 0.0002 ) * 0.5;

				renderer.render( scene, camera );

			}

		</script>
<% elsif @user.woda == '1' %>

	/**
	 * 
	 */
	function Wave() {
		
		/** The current dimensions of the screen (updated on resize) */
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;
		
		/** Wave settings */
		var DENSITY = .75;
		var FRICTION = 1.14;
		var MOUSE_PULL = 0.09; // The strength at which the mouse pulls particles within the AOE
		var AOE = 200; // Area of effect for mouse pull
		var DETAIL = Math.round( WIDTH / 60 ); // The number of particles used to build up the wave
		var WATER_DENSITY = 1.07;
		var AIR_DENSITY = 1.02;
		var TWITCH_INTERVAL = 2000; // The interval between random impulses being inserted into the wave to keep it moving
		
		/** Twitter interaction settings */
		var TWITTER_QUERY = 'water'; // The search term for tweets
		var TWEETS_PER_PAGE = 20; // The number of tweets that will be fetched per server call
		var TWEETS_FREQUENCY = 400; // Milliseconds between tweet bubbles being added to the wave
		
		/** Bubble settings */
		var MAX_BUBBLES = 60; // The maximum number of bubbles visible before FIFO is applied
		var BIG_BUBBLE_DISSOLVE = 20; // How many particles a bubble dissolves into when being clicked
		var SMALL_BUBBLE_DISSOLVE = 6;
		
		/** Couple of counters to keep track of the Twitter interaction */
		var twitterPolls = 1; // Counts how many times data has been fetched from twitter
		var twitterRetries = 0; // Counts how many times we fail to retrieve results from twitter
		var twitterMaxId = 0; // The ID of the oldest tweet that's been downloaded
		
		var mouseIsDown, isDownloadingTweets = false;
		var ms = {x:0, y:0}; // Mouse speed
		var mp = {x:0, y:0}; // Mouse position
		
		var canvas, context, particles, bubbles, tweets;
		
		var timeUpdateInterval, tweetUpdateInterval, twitchInterval;
		
		/**
		 * Constructor.
		 */
		this.Initialize = function( canvasID ) {
			canvas = document.getElementById( canvasID );
			
			if (canvas && canvas.getContext) {
				context = canvas.getContext('2d');
				
				particles = [];
				tweets = [];
				bubbles = [];
				
				$("body").append('<div id="tweet"></div>');
				
				// Generate our wave particles
				for( var i = 0; i < DETAIL+1; i++ ) {
					particles.push( { 
						x: WIDTH / (DETAIL-4) * (i-2), // Pad by two particles on each side
						y: HEIGHT*.5,
						original: {x: 0, y: HEIGHT * .5},
						velocity: {x: 0, y: Math.random()*3}, // Random for some initial movement in the wave
						force: {x: 0, y: 0},
						mass: 10
					} );
				}
				
				$(canvas).mousemove(MouseMove);
				$(canvas).mousedown(MouseDown);
				$(canvas).mouseup(MouseUp);
				$(window).resize(ResizeCanvas);
				
				timeUpdateInterval = setInterval( TimeUpdate, 40 );
				tweetUpdateInterval = setInterval( CreateBubble, TWEETS_FREQUENCY );
				twitchInterval = setInterval( Twitch, TWITCH_INTERVAL );
				
				DownloadTweets();
				CreateBubble();
				ResizeCanvas();
				
			}
		};
		
		/**
		 * Stops downloading and showing tweets.
		 */
		function Terminate( message ) {
			clearInterval( tweetUpdateInterval );
			isDownloadingTweets = true;
			
			alert( message );
		}
		
		/**
		 * Gets the next tweet in queue. If there are
		 * less than five tweets remaining, download a
		 * new batch.
		 */
		function GetTweet() {
			if( tweets.length < 5 && !isDownloadingTweets ) {
				DownloadTweets();
			}
			
			if (tweets.length > 0) {
				return tweets.shift();
			}
		}
		
		/**
		 * 
		 */
		function DownloadTweets() {
			isDownloadingTweets = true;
			
			if( twitterPolls ++ > 20 ) {
				Terminate( "That's it. No more tweets for you." );
			}
			
			$.post("search.php", {query: TWITTER_QUERY, max_id: twitterMaxId, rpp: TWEETS_PER_PAGE}, function(xml){
				
				if( !$('entry',xml) || $('entry',xml).length == 0 ) {
					if (twitterRetries++ > 3) {
						Terminate("Oops, Twitter doesn't want to serve us at the moment.");
					}
				}
				
				$('entry',xml).each(function(i){
					var tweet = {};
					tweet.title = $(this).find("title").text();   
					tweet.content = $(this).find("content").text();   
					tweet.published = $(this).find("published").text();   
					tweet.link = $(this).find("link").text();   
					tweet.authorURI = $(this).find("uri").text();
					tweet.author = $(this).find("name").text();
					tweet.author = "@" + tweet.author.slice(0, tweet.author.indexOf(" "));
					tweet.id = $(this).find("id").text();
					tweet.id = tweet.id.slice( tweet.id.lastIndexOf(":") + 1 );
					
					if( i == $('entry',xml).length - 1 ) {
						twitterMaxId = parseInt( tweet.id ) - 1;
					}
					
					tweets.push( tweet );
				});
				
				isDownloadingTweets = false;
				
			});
		}
		
		/**
		 * 
		 */
		function ShowTweet( bubbleIndex ) {
			var tweet = GetTweet();
			var tweetMarkup = tweet.content + "<br/><p class='author'>by: <a href='"+tweet.authorURI+"'>" + tweet.author + "</p>";
			$("#tweet").hide().html( tweetMarkup ).fadeIn();
			
			DissolveBubble( bubbleIndex );
		}
		
		/**
		 * Inserts a random impulse to keep the wave moving.
		 * Impulses are only inserted if the mouse is not making
		 * quick movements.
		 */
		function Twitch() {
			if( ms.x < 6 || ms.y < 6 ) {
				var forceRange = 5; // -value to +value
				InsertImpulse( Math.random() * WIDTH, (Math.random()*(forceRange*2)-forceRange ) );
			}
		}
		
		/**
		 * Inserts an impulse in the wave at a specific position.
		 * 
		 * @param positionX the x coordinate where the impulse
		 * should be inserted
		 * @param forceY the force to insert
		 */
		function InsertImpulse( positionX, forceY ) {
			var particle = particles[Math.round( positionX / WIDTH * particles.length )];
			
			if( particle ) {
				particle.force.y += forceY;
			}
		}
		
		/**
		 * 
		 */
		function TimeUpdate(e) {
			
			var gradientFill = context.createLinearGradient(WIDTH*.5,HEIGHT*.2,WIDTH*.5,HEIGHT);
			gradientFill.addColorStop(0,'#00AABB');
			gradientFill.addColorStop(1,'rgba(0,200,250,0)');
			
			context.clearRect(0, 0, WIDTH, HEIGHT);
			context.fillStyle = gradientFill;
			context.beginPath();
			context.moveTo(particles[0].x, particles[0].y);
			
			var len = particles.length;
			var i;
			
			var current, previous, next;
			
			for( i = 0; i < len; i++ ) {
				current = particles[i];
				previous = particles[i-1];
				next = particles[i+1];
				
				if (previous && next) {
					
					var forceY = 0;
					
					forceY += -DENSITY * ( previous.y - current.y );
					forceY += DENSITY * ( current.y - next.y );
					forceY += DENSITY/15 * ( current.y - current.original.y );
					
					current.velocity.y += - ( forceY / current.mass ) + current.force.y;
					current.velocity.y /= FRICTION;
					current.force.y /= FRICTION;
					current.y += current.velocity.y;
					
					var distance = DistanceBetween( mp, current );
					
					if( distance < AOE ) {
						var distance = DistanceBetween( mp, {x:current.original.x, y:current.original.y} );
						
						ms.x = ms.x * .98;
						ms.y = ms.y * .98;
						
						current.force.y += (MOUSE_PULL * ( 1 - (distance / AOE) )) * ms.y;
					}
					
					// cx, cy, ax, ay
					context.quadraticCurveTo(previous.x, previous.y, previous.x + (current.x - previous.x) / 2, previous.y + (current.y - previous.y) / 2);
				}
				
			}
			
			context.lineTo(particles[particles.length-1].x, particles[particles.length-1].y);
			context.lineTo(WIDTH, HEIGHT);
			context.lineTo(0, HEIGHT);
			context.lineTo(particles[0].x, particles[0].y);
			
			context.fill();
			
			len = bubbles.length;
			
			context.fillStyle = "#rgba(0,200,255,0)";
			context.beginPath();
			
			var b, p, d;
			
			for (i = 0; i < len; i++) {
				var b = bubbles[i];
				var p = GetClosestParticle( b );
				var d = DistanceBetween( mp, b );
				
				b.velocity.y /= ( b.y > p.y ) ? WATER_DENSITY : AIR_DENSITY;
				b.velocity.y += ( p.y > b.y ) ? 1/b.mass : -((b.y-p.y)*0.01)/b.mass;
				b.y += b.velocity.y;
				
				if( b.x > WIDTH - b.currentSize ) b.velocity.x = -b.velocity.x;
				if( b.x < b.currentSize ) b.velocity.x = Math.abs(b.velocity.x);
				
				b.velocity.x /= 1.04;
				b.velocity.x = b.velocity.x < 0 ? Math.min( b.velocity.x, -.8/b.mass ) : Math.max( b.velocity.x, .8/b.mass )
				b.x += b.velocity.x;
				
				if( d < AOE ) {
					// The bubble is within the AOE, apply horizontal mouse pull relative to distance
					//b.velocity.x += MOUSE_PULL * ( ( AOE - d ) / AOE * b.mass ) * ms.x;
				}
				
				if( b.dissolved == false ) {
					context.moveTo(b.x,b.y);
					context.arc(b.x,b.y,b.currentSize,0,Math.PI*2,true);
				}
				else {
					b.velocity.x /= 1.15;
					b.velocity.y /= 1.05;
					
					while( b.children.length < b.dissolveSize ) {
						b.children.push( { x:0, y:0, size: Math.random()*b.dissolveSize, velocity: { x: (Math.random()*20)-10, y: -(Math.random()*10) } } );
					}
					
					for( var j = 0; j < b.children.length; j++ ) {
						var c = b.children[j];
						c.x += c.velocity.x;
						c.y += c.velocity.y;
						c.velocity.x /= 1.1;
						c.velocity.y += 0.4;
						c.size /= 1.1;
						
						context.moveTo(b.x+c.x,b.y+c.y); // needed in ff
						context.arc(b.x+c.x,b.y+c.y,c.size,0,Math.PI*2,true);
					}
					
				}
				
			}
			
			context.fill();
		}
		
		/**
		 * 
		 */
		function GetClosestParticle(point){
			var closestIndex = 0;
			var closestDistance = 1000;
			
			var len = particles.length;
			
			for( var i = 0; i < len; i++ ) {
				var thisDistance = DistanceBetween( particles[i], point );
				
				if( thisDistance < closestDistance ) {
					closestDistance = thisDistance;
					closestIndex = i;
				}
				
			}
			
			return particles[closestIndex];
		}
		
		/**
		 * 
		 */
		function CreateBubble() {
			if( bubbles.length > MAX_BUBBLES ) {
				var i = 0;
				
				if( bubbles[i].dissolved ) {
					// Find a bubble thats not already on its way to dissolving
					for( ; i < bubbles.length; i++ ) {
						if( bubbles[i].dissolved == false ) {
							bubbles[i].dissolveSize = SMALL_BUBBLE_DISSOLVE;
							DissolveBubble( i );
							break;
						}
					}
				}
				else {
					DissolveBubble( i );
				}
				
			}
			
			var minSize = 15;
			var maxSize = 30;
			var size = minSize + Math.random() * ( maxSize - minSize );
			var catapult = 30;
			
			var b = {
				x: maxSize + ( Math.random() * ( WIDTH - maxSize ) ),
				y: HEIGHT - maxSize,
				velocity: {x: (Math.random()*catapult)-catapult/2,y: 0},
				size: size,
				mass: (size / maxSize)+1,
				dissolved: false,
				dissolveSize: BIG_BUBBLE_DISSOLVE,
				children: []
			};
			
			b.currentSize = b.size;
			
			bubbles.push(b);
		}
		function DissolveBubble( index ) {
			var b = bubbles[index];
			
			if( b.dissolved == false ) {
				b.dissolved = true;
				
				setTimeout( function() {
					for( var i = 0; i < bubbles.length; i++ ) {
						if( bubbles[i] == b ) {
							bubbles.splice(i,1);
							break;
						}
					}
					
				}, 2000 );
			}
		}
		
		/**
		 * 
		 */
		function MouseMove(e) {
			ms.x = Math.max( Math.min( e.layerX - mp.x, 40 ), -40 );
			ms.y = Math.max( Math.min( e.layerY - mp.y, 40 ), -40 );
			
			mp.x = e.layerX;
			mp.y = e.layerY;
			
		}
		function MouseDown(e) {
			mouseIsDown = true;
			
			var len = bubbles.length;
			
			var closestIndex = 0;
			var closestDistance = 1000;
			
			for( var i = 0; i < len; i++ ) {
				var thisDistance = DistanceBetween( bubbles[i], mp );
				
				if( thisDistance < closestDistance ) {
					closestDistance = thisDistance;
					closestIndex = i;
				}
				
			}
			
			if (bubbles.length && closestDistance < 150) {
				ShowTweet( closestIndex );
			}
		}
		function MouseUp(e) {
			mouseIsDown = false;
		}
		
		/**
		 * 
		 */
		function ResizeCanvas(e) {
			WIDTH = window.innerWidth;
			HEIGHT = window.innerHeight;
			
			canvas.width = WIDTH;
			canvas.height = HEIGHT;
			
			$("#tweet").css( "top", HEIGHT * .7 );
			
			for( var i = 0; i < DETAIL+1; i++ ) {
				particles[i].x = WIDTH / (DETAIL-4) * (i-2);
				particles[i].y = HEIGHT*.5;
				
				particles[i].original.x = particles[i].x;
				particles[i].original.y = particles[i].y;
			}
		}
		
		/**
		 * 
		 */
		function DistanceBetween(p1,p2) {
			var dx = p2.x-p1.x;
			var dy = p2.y-p1.y;
			return Math.sqrt(dx*dx + dy*dy);
		}
		
	}
	
	var wave = new Wave();
	wave.Initialize( 'world' );
<% end %>
